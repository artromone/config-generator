package main

import (
	"fmt"
	"os"
	"regexp"
	"strings"
	"text/template"
)

type ConfigField struct {
	Name         string
	EnvVar       string
	GoType       string
	DefaultValue string
	Required     bool
	YamlPath     string
}

type ConfigStruct struct {
	Name   string
	Fields []ConfigField
}

func main() {
	if len(os.Args) < 2 {
		fmt.Println("Usage: go run tools/configgen/main.go generate")
		os.Exit(1)
	}

	switch os.Args[1] {
	case "generate":
		generateConfig()
	case "validate":
		validateConfig()
	default:
		fmt.Printf("Unknown command: %s\n", os.Args[1])
		os.Exit(1)
	}
}

func generateConfig() {
	// Читаем шаблон
	templateContent, err := os.ReadFile("config/config.yaml.template")
	if err != nil {
		panic(fmt.Sprintf("Failed to read template: %v", err))
	}

	// Извлекаем переменные
	fields := extractEnvVars(string(templateContent))

	// Группируем по секциям
	structs := groupFieldsBySection(fields)

	// Генерируем Go код
	generateGoStructs(structs)

	// Генерируем .env файлы
	generateEnvFiles(fields)

	fmt.Println("✅ Configuration files generated successfully!")
}

func extractEnvVars(content string) []ConfigField {
	// Regex для поиска ${VAR_NAME:default}
	re := regexp.MustCompile(`\$\{([^}:]+)(?::([^}]*))?\}`)
	matches := re.FindAllStringSubmatch(content, -1)

	var fields []ConfigField
	seen := make(map[string]bool)

	for _, match := range matches {
		envVar := match[1]
		defaultValue := ""
		if len(match) > 2 {
			defaultValue = match[2]
		}

		if seen[envVar] {
			continue
		}
		seen[envVar] = true

		field := ConfigField{
			Name:         envVarToFieldName(envVar),
			EnvVar:       envVar,
			GoType:       inferGoType(defaultValue),
			DefaultValue: defaultValue,
			Required:     defaultValue == "",
			YamlPath:     getYamlPath(content, envVar),
		}

		fields = append(fields, field)
	}

	return fields
}

func envVarToFieldName(envVar string) string {
	parts := strings.Split(envVar, "_")
	var result strings.Builder
	for _, part := range parts {
		result.WriteString(strings.Title(strings.ToLower(part)))
	}
	return result.String()
}

func inferGoType(defaultValue string) string {
	if defaultValue == "" {
		return "string"
	}

	switch strings.ToLower(defaultValue) {
	case "true", "false":
		return "bool"
	default:
		// Проверяем на число
		if matched, _ := regexp.MatchString(`^\d+$`, defaultValue); matched {
			return "int"
		}
		return "string"
	}
}

func getYamlPath(content, envVar string) string {
	// Простая логика для определения пути в YAML
	lines := strings.Split(content, "\n")
	for _, line := range lines {
		if strings.Contains(line, "${"+envVar) {
			// Извлекаем yaml path из отступов
			return extractYamlPath(line)
		}
	}
	return ""
}

func extractYamlPath(line string) string {
	// Упрощенная реализация
	trimmed := strings.TrimSpace(line)
	if strings.Contains(trimmed, ":") {
		return strings.Split(trimmed, ":")[0]
	}
	return ""
}

func groupFieldsBySection(fields []ConfigField) []ConfigStruct {
	sections := make(map[string][]ConfigField)

	for _, field := range fields {
		section := getSectionFromEnvVar(field.EnvVar)
		sections[section] = append(sections[section], field)
	}

	var structs []ConfigStruct
	for section, fields := range sections {
		structs = append(structs, ConfigStruct{
			Name:   section,
			Fields: fields,
		})
	}

	return structs
}

func getSectionFromEnvVar(envVar string) string {
	parts := strings.Split(envVar, "_")
	if len(parts) > 1 {
		return strings.Title(strings.ToLower(parts[0]))
	}
	return "App"
}

func generateGoStructs(structs []ConfigStruct) {
	tmpl := `// Code generated by configgen. DO NOT EDIT.
package config

import (
	"fmt"
	"github.com/knadh/koanf/v2"
	"github.com/knadh/koanf/parsers/yaml"
	"github.com/knadh/koanf/providers/env"
	"github.com/knadh/koanf/providers/file"
)

var k = koanf.New(".")

type Config struct {
{{range .}}	{{.Name}} {{.Name}}Struct ` + "`koanf:\"{{.Name | lower}}\"`" + `
{{end}}}

{{range .}}
type {{.Name}}Struct struct {
{{range .Fields}}	{{.Name}} {{.GoType}} ` + "`koanf:\"{{.YamlPath}}\" env:\"{{.EnvVar}}\"`" + `
{{end}}}
{{end}}

func NewConfig() (*Config, error) {
	// Загружаем конфигурацию из файла
	if err := k.Load(file.Provider("config/config.yaml"), yaml.Parser()); err != nil {
		return nil, fmt.Errorf("error loading config file: %w", err)
	}

	// Переопределяем переменными окружения
	if err := k.Load(env.Provider("", ".", func(s string) string {
		return strings.Replace(strings.ToLower(s), "_", ".", -1)
	}), nil); err != nil {
		return nil, fmt.Errorf("error loading env vars: %w", err)
	}

	var cfg Config
	if err := k.Unmarshal("", &cfg); err != nil {
		return nil, fmt.Errorf("error unmarshaling config: %w", err)
	}

	return &cfg, nil
}

func (c *Config) Validate() error {
	// Добавьте свою валидацию здесь
	return nil
}
`

	t := template.Must(template.New("config").Funcs(template.FuncMap{
		"lower": strings.ToLower,
	}).Parse(tmpl))

	file, err := os.Create("config/config.go")
	if err != nil {
		panic(err)
	}
	defer file.Close()

	if err := t.Execute(file, structs); err != nil {
		panic(err)
	}
}

func generateEnvFiles(fields []ConfigField) {
	// Генерируем .env.example
	generateEnvExample(fields)

	// Генерируем .env.local если не существует
	generateEnvLocal(fields)
}

func generateEnvExample(fields []ConfigField) {
	file, err := os.Create(".env.example")
	if err != nil {
		panic(err)
	}
	defer file.Close()

	file.WriteString("# Generated environment variables\n")
	file.WriteString("# Copy this file to .env.local and fill in your values\n\n")

	for _, field := range fields {
		if field.Required {
			file.WriteString(fmt.Sprintf("%s=\n", field.EnvVar))
		} else {
			file.WriteString(fmt.Sprintf("%s=%s\n", field.EnvVar, field.DefaultValue))
		}
	}
}

func generateEnvLocal(fields []ConfigField) {
	if _, err := os.Stat(".env.local"); err == nil {
		// Файл уже существует, не перезаписываем
		return
	}

	file, err := os.Create(".env.local")
	if err != nil {
		panic(err)
	}
	defer file.Close()

	file.WriteString("# Local environment variables\n")
	file.WriteString("# Add your actual values here\n\n")

	for _, field := range fields {
		file.WriteString(fmt.Sprintf("%s=%s\n", field.EnvVar, field.DefaultValue))
	}
}

func validateConfig() {
	fmt.Println("🔍 Validating configuration...")

	// Проверяем соответствие между template и .env файлами
	templateFields := extractEnvVarsFromTemplate()
	envFields := extractEnvVarsFromEnvFile()

	// Проверяем отсутствующие переменные
	missing := findMissingVars(templateFields, envFields)
	if len(missing) > 0 {
		fmt.Printf("❌ Missing environment variables: %v\n", missing)
		os.Exit(1)
	}

	// Проверяем лишние переменные
	extra := findExtraVars(templateFields, envFields)
	if len(extra) > 0 {
		fmt.Printf("⚠️  Extra environment variables: %v\n", extra)
	}

	fmt.Println("✅ Configuration validation passed!")
}

func extractEnvVarsFromTemplate() []string {
	content, err := os.ReadFile("config/config.yaml.template")
	if err != nil {
		panic(err)
	}

	re := regexp.MustCompile(`\$\{([^}:]+)(?::([^}]*))?\}`)
	matches := re.FindAllStringSubmatch(string(content), -1)

	var vars []string
	seen := make(map[string]bool)
	for _, match := range matches {
		envVar := match[1]
		if !seen[envVar] {
			vars = append(vars, envVar)
			seen[envVar] = true
		}
	}

	return vars
}

func extractEnvVarsFromEnvFile() []string {
	content, err := os.ReadFile(".env.example")
	if err != nil {
		return []string{}
	}

	var vars []string
	lines := strings.Split(string(content), "\n")
	for _, line := range lines {
		line = strings.TrimSpace(line)
		if line != "" && !strings.HasPrefix(line, "#") {
			parts := strings.Split(line, "=")
			if len(parts) >= 2 {
				vars = append(vars, parts[0])
			}
		}
	}

	return vars
}

func findMissingVars(template, env []string) []string {
	envMap := make(map[string]bool)
	for _, v := range env {
		envMap[v] = true
	}

	var missing []string
	for _, v := range template {
		if !envMap[v] {
			missing = append(missing, v)
		}
	}

	return missing
}

func findExtraVars(template, env []string) []string {
	templateMap := make(map[string]bool)
	for _, v := range template {
		templateMap[v] = true
	}

	var extra []string
	for _, v := range env {
		if !templateMap[v] {
			extra = append(extra, v)
		}
	}

	return extra
}
